[TOC]



## CLR对泛型的处理

具有泛型类型参数的类型仍然是类型，CLR 同样会为它创建内部的类型对象。这一点适合应用类型(类)、值类型(结构)、接口类型和委托类型。
为所有类型参数都传递了实际的数据类型，类型就成为封闭类型，反之没有给所有的类型参数都指定实际的数据类型的泛型被称为开放类型。无论时封闭类型还是开放类型CLR都会为其创建对应类型对象。但是对于开放类型来说CLR不允许创建开放类型的实例。

使用泛型类型参数的方法在进行 JIT 编译时，CLR 获取方法的 IL，用指定的类型实参替换，然后创建恰当的本机代码(这些代码为操作指定数据类型“量身定制”)。这正是你希望的，也是泛型的重要特点。但这样做有一个缺点：CLR 要为每种不同的方法/类型组合生成本机代码。我们将这个现象称为代码爆炸。它可能造成应用程序的工作集显著增大，从而损害性能。

幸好，CLR 内建了一些优化措施能缓解代码爆炸。首先，假如为特定的类型实参调用了一个方法，以后再用相同的类型实参调用这个方法，CLR 只会为这个方法/类型组合编译一次代码。所以，如果一个程序集使用List<DateTime>，一个完全不同的程序集(加载到同一个 AppDomain 中)也使用List<DateTime>编译一次方法。这样就显著缓解了代码爆炸。

CLR 还有另一个优化，它认为所有引用类型实参都完全相同，所以代码能够共享。例如，CLR 为 List<String>的方法编译的代码可直接用于List<Stream>的方法，因为String和Stream均为引用类型。事实上，对于任何引用类型，都会使用相同的代码。CLR 之所以能执行这个优化，是因为所有引用类型的实参或变量实际只是指向堆上对象的指针(32 位 Windows 系统上是 32 位指针；64 位 Windows 系统上是 64 为指针)，而所有对象指针都以相同方式操纵。

但是，假如某个类型实参是值类型，CLR 就必须专门为那个值类型生成本机代码。这是因为值类型的大小不定。即使两个值类型大小一样(比如 Int32和UInt32，两者都是32位)，CLR仍然无法共享代码，因为可能要用不同的本机 CPU 指令来操纵这些值。


## CLR对接口的处理
类型加载到 CLR 中时，会为该类型创建并初始化一个方法表(参见第 1 章“CLR的执行模型”)。在这个方法表中，类型引入的每个新方法都有对应的记录项；另外，还为该类型继承的所有虚方法添加了记录项。继承的虚方法既有继承层次结构中的各个基类型定义的，也有接口类型定义的。所以，对于下面这个简单的类型定义：
```csharp
internal sealed class SimpleType : IDisposable {
    public void Dispose() { Console.WriteLine("Dispose"); }
}
```
类型的方法表将包含以下方法的记录项。

- Object(隐式继承的基类)定义的所有虚实例方法。
- IDisposable(继承的接口)定义所有接口方法。本例只有一个方法，即Dispose，因为IDisposable接口只定义了这个方法。
- SimpleType引入的新方法 Dispose。
为简化编程，C#编译器假定 SimpleType 引入的Dispose方法是对IDisposable的Dispose方法的可访问性是public，而接口方法的签名和新引入的方法完全一致。也就是说，两个方法具有相同的参数和返回类型。顺便说一句，如果新的Dispose方法被标记为virtual，C#编译器仍然认为该方法匹配接口方法。

C#编译器将新方法和接口方法匹配起来之后，会生成元数据，指明 SimpleType 类型的方法表中的两个记录项应引用同一个实现。为了更清楚地理解这一点，下面的代码演示了如何调用类的公共Dispose方法以及如何调用IDisposable的Dispose方法在类中的实现：
```csharp
public sealed class Program {
    public static void Main() {
        SimpleType st = new SimpleType();

        // 调用公共 Dispose 方法实现
        st.Dispose();

        // 调用 IDisposable 的 Dispose 方法的实现
        IDisposable d = st;
        d.Dispose();
    }
}
```
在第一个 Dispose 方法调用中，调用的是 SimpleType 定义的 Dispose 方法。然后定义 IDisposable 接口类型的变量d，它引用SimpleType对象st。调用d.Dispose()时，调用的是IDisposable接口的Dispose方法的实现，所以会执行相同的代码。在这个例子中，两个调用你看不出任何区别。输出结果如下所示：
```
Dispose
Dispose
```
现在重写 `SimpleType`，以便于看出区别：
```csharp
internal sealed class SimpleType : IDisposable {
    public void Dispose() { Console.WriteLine("public Dispose"); }
    void IDisposable.Dispose() { Console.WriteLine("IDisposable Dispose"); }
}
```
在不改动前面的Main方法的前提下，重新编译并再次运行程序，输出结果如下所示：
```
public Dispose
IDisposable Dispose       
```
在 C# 中，将定义方法的那个接口的名称作为方法名前缀(例如 IDisposable.Dispose)，就会创建显式接口方法实现(Explicit Interface Method Implementation，EIMI①)。注意，C# 中不允许在定义显式接口方法时指定可访问性(比如 public或private)。但是，编译器生成方法的元数据时，可访问性会自动设为 private，防止其他代码在使用类的实例时直接调用接口方法。只有通过接口类型的变量才能调用接口方法。

还要注意，EIMI 方法不能标记为 virtual，所以不能被重写。这是用于 EIMI 方法并非真的是类型的对象模型的一部分，它只是将接口(一组行为或方法)和类型连接起来，同时避免公开行为/方法。如果觉得这一点不好理解，那么你的感觉没有错！它就是不太好理解。本章稍后会介绍 EIMI 有用的一些场合。
