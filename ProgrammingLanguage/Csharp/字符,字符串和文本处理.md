[TOC]

# CLR 中的字符
在 CLR 中，所有字符都表示成 16 位 Unicode 码值

# string 实例的构造
编译源代码时，编译器必须处理每个字面值(literal)字符串，并在托管模块的元数据中嵌入。同一个字符串在源代码中多次出现，把它们都嵌入元数据会使生成的文件无谓地增大。

为了解决这个问题，许多编译器(包括 C#编译器)只在模块的元数据中只将字面值字符串写入一次。引用该字符串的所有代码都被改成引用元数据中的同一个字符串。编译器将单个字符串的多个实例合并成一个实例，能显著减少模块的大小。但这并不是新技术，C/C++ 编译器多年来一直在采用这个技术(Micrisoft 的 C/C++ 编译器称之为“字符串池”)。尽管如此，字符串池仍是提升字符串性能的另一种行之有效的方式，而你应注意到它的存在。观察下面的代码

```csharp
using System;

public static class Program {
    public static void Main() {
        String s = "Hi there.";     // 错误
        Console.WriteLine(s);
    }
}
```
编译代码并检查 IL(使用 ILDasm.exe)，会看到以下内容：
```
.method public hidebysig static void Main() cil managed
{
    .entrypoint
    // Code size 13 (0xd)
    .maxstack 1
    .locals init ([0] string s)
    IL_0000: ldstr "Hi there."
    IL_0005: stloc.0
    IL_0006: ldloc.0
    IL_0007: call void [mscorlib]System.Console::WriteLine(string)
    IL_000c: ret
} // end of method Program::Main
```
用于构造对象新实例的 IL 指令是 newobj。但上述 IL 代码中并没有出现newobj指令，只有一个特殊ldstr(即 load string)指令，它使用从元数据获得的字面值(literal)字符串构造String对象。这证明 CLR 实际是用一种特殊方式构造字面值String对象。

```csharp
// 三个字面值(literal)字符串连接成一个字面值字符串
String s = "Hi" + " " + "there.";
```
在上述代码中，由于所有字符串都是字面值，所以 C# 编译器能在编译时连接它们，最终只将一个字符串(即"Hi there.")放到模块的元数据中。对非字面值字符串使用+操作符，连接则在运行时进行。运行时连接不要使用+操作符，因为这样会在堆上创建多个字符串对象，而堆是需要垃圾回收的，对性能有影响。


# string 类型的不可变性
字符串不可变还意味着在操纵或访问字符串时不会发生线程同步问题。此外，CLR 可通过一个String对象共享多个完全一致的String内容。这样能减少系统中的字符串数量——从而节省内存——这就是所谓的”字符串留用“(string interning)。
因为字符串是“不可变”(immutable)的。在内存中只保留字符串的一个实例将显著提升内存的利用率。需要引用字符串的所有变量只需指向单独一个字符串的所有变量只需指向单独一个字符串对象。

CLR 初始化时会创建一个内部哈希表。在这个表中，键(key)是字符串，而值(value)是对托管堆中的String对象的引用。哈希表最开始是空的(理应如此)。String类提供了两个方法，便于你访问这个内部哈希表：

```csharp
public static String Intern(String str);
public static String IsInterned(String str);
```

第一个方法 Intern 获取一个 String， 获得它的哈希码，并在内部哈希表中检查是否有相匹配的。如果存在完全相同的字符串，就返回对现有 String 对象的引用。如果不存在完全相同的字符串，就创建字符串的副本，将副本添加到内部哈希表中，返回对该副本的引用。如果应用程序不再保持对原始String对象的引用，垃圾回收器就可释放那个字符串的内存。注意垃圾回收器不能释放内部哈希表引用的字符串，因为哈希表正在容纳对它们的引用。 除非卸载 AppDomain 或进程终止，否则内部哈希表引用的 String 对象不能被释放。

和 Intern 方法一样，IsInterned 方法也获取一个 String，并在内部哈希表中查找它。如果哈希表中有匹配的字符串，IsInterned就返回对这个留用(interned)字符串对象的引用。但如果没有，IsInterned会返回null，不会将字符串添加到哈希表中。

程序集加载时，CLR 默认留用程序集的元数据中描述的所有字面值(literal)字符串对象的引用。但如果没有，IsInterned就返回对这个留用(interned)字符串对象的引用。但如果没有，IsInterned会返回null，不会将字符串添加到哈希表中。

程序集加载时，CLR 默认留用程序集的元数据中描述的所有字面值(literal)字符串。Microsoft 知道可能因为额外的哈希表查找而显著影响性能，所以现在能禁用此功能。如果程序集用System.Runtime.CompilerServices.CompilationRelaxationsAttribute 进行了标记，并指定了 System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning标志值，那么根据 ECMA 规范，CLR 可能选择不留用那个程序集的元数据中定义的所有字符串。注意，为了提升应用程序性能，C#编译器在编译程序时总是指定上述两个特性和标志。


# StringBuilder
StringBuilder对象包含一个字段，该字段引用了由Char结构构成的数组。可利用StringBuilder的各个成员来操纵该字符数组，高效率地缩短字符串或更改字符串中的字符。如果字符串变大，超过了事先分配的字符数组大小，StringBuilder会自动分配一个新的、更大的数组，复制字符，并开始使用新数组。前一个数组被垃圾回收。