# 网络服务器编程

## 服务端的实现

1. 服务端可以使用多线程, 状态检测poll 或者是 多路复用select 等方案实现
2. 做好对应的异常处理
3. 一般客户端不会使用poll或者select等方式来实现, 而是使用异步(多线程)的方案. 这样做是为了减少客户端的性能开销, 避免每一帧都需要去检查网络数据.
4. **解耦** - 网络模块一般是作为一个底层模块用的,它应该和具体的游戏逻辑分开

## 系统缓冲区

在网络上发送和接收数据实际上是通过操作系统上的网络协议栈来实现的. 网络协议栈中存在发送和接受缓冲区. 我们使用 网络套接字接口来进行数据的发送和接受实际上是在对应的发送接收缓冲区上进行操作.

## 粘包问题

粘包是指发送方发送多个数据包, 而接收方在接收时这些数据包粘连在了一起.导致数据包不能完整的体现发送的数据. 一般有三种方法来解决粘包问题

1. 长度信息法 - 长度信息法是指在每个数据包前面加上长度信息。每次接收到数
据后，先读取表示长度的字节，如果缓冲区的数据长度大于要取的字
节数，则取出相应的字节，否则等待下一次数据接收。游戏开发中最常用的方法
2. 固定长度法 - 每次都以相同的长度发送数据
3. 结束符好法 - 规定一个结束符号，作为消息间的分隔符。

## 大小端问题

网络数据都是以大端的字节序来进行数据传输的, 市面上部分手机采用大端字节序, 部分手机采用小端的字节序. 有些手机甚至可以由硬件来选择使用大端模式或者时小端模式. 为了兼容所有的机型, 可以规定写入缓冲区的数据必须按照小端的模式来进行存储.

## 发送不完整问题

在网络拥堵的环境中可能会出现网络协议栈中的发送缓冲区爆满的情况, 此时如果再向发送缓冲区中添加数据则会失败. 会导致不完整的数据被发送. **通过引入额外的缓冲队列来缓冲需要发送的数据可以解决这个问题, 但是要注意不能同时发送多条 数据否则会造成混乱**

##  多线程之间的条件竞争问题

当存在多个线程同时读写一个资源的时候就有可能发生条件竞争, 这种情况有可能发生再客户端或者时服务端上. 我们可以使用 **锁** 来解决这个问题, 但是要注意将临界区设计得足够小从而获取更高得效率
